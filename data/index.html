<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ESP32 Temp Logger</title>
    <style>
      :root{
        --bg:#0f1720; --card:#0b1220; --text:#e6eef6; --muted:#9fb0c8; --accent:#4fd1c5;
      }
      @media (prefers-color-scheme: light){
        :root{ --bg:#f6f9fc; --card:#ffffff; --text:#06202b; --muted:#456275; --accent:#0ea5a4; }
      }
      html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial; background:var(--bg); color:var(--text); -webkit-font-smoothing:antialiased}
      .app{max-width:900px;margin:0 auto;padding:18px;box-sizing:border-box}
      header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
      h1{font-size:1rem;margin:0;color:var(--accent)}
      .controls{display:flex;gap:8px;flex-wrap:wrap}
      .card{background:var(--card);border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
      .main{display:grid;grid-template-columns:1fr;gap:12px}
      .temp-display{display:flex;align-items:center;justify-content:space-between;padding:18px;border-radius:10px}
      .temp-left{display:flex;flex-direction:column}
      .temp-value{font-weight:700;font-size:3.6rem;line-height:1}
      .temp-units{font-size:1.1rem;opacity:.9}
      .small{color:var(--muted);font-size:.95rem}
      .actions{display:flex;gap:8px;align-items:center}
      button, select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:10px 12px;border-radius:8px;font-size:0.95rem}
      button.primary{background:linear-gradient(90deg,var(--accent),#7af0e6);color:#022029;border:0}
      .muted{opacity:.85}
      .row{display:flex;gap:8px;align-items:center}
      .flex{flex:1}
      #chart{width:100%;height:160px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);display:block}
      footer{margin-top:12px;color:var(--muted);font-size:.85rem;text-align:center}
      /* Mobile tweaks */
      @media (max-width:520px){
        .temp-value{font-size:2.6rem}
        header{gap:8px}
        .card{padding:12px}
      }
      .toggle{display:inline-flex;align-items:center;gap:8px}
      .link{color:var(--accent);text-decoration:none}
      .hidden{display:none}
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <h1>ESP32 Temp Logger</h1>
        <div class="controls">
          <label class="toggle small" title="Toggle dark/light mode">
            <input id="themeToggle" type="checkbox" aria-label="Toggle theme" />
            <span class="small">Dark / Light</span>
          </label>
        </div>
      </header>

      <main class="main">
        <section class="card temp-display" aria-live="polite">
          <div class="temp-left">
            <div class="temp-value" id="tempValue">--.-</div>
            <div class="temp-units small" id="tempMeta">-- &nbsp; • &nbsp; interval: --s</div>
          </div>
          <div class="actions">
            <div class="row">
              <select id="intervalSelect" aria-label="Sampling interval">
                <option value="1">1s</option>
                <option value="2">2s</option>
                <option value="5">5s</option>
                <option value="10">10s</option>
                <option value="30">30s</option>
                <option value="60">60s</option>
              </select>
              <button id="setIntervalBtn">Set</button>
            </div>
            <div class="row">
              <button id="startLogBtn" class="primary">Start Log</button>
            </div>
          </div>
        </section>

        <section class="card" id="controlsCard">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
            <div class="small muted">Status: <span id="statusText">Connecting…</span></div>
            <div style="display:flex;gap:8px;align-items:center">
              <label class="toggle small"><input id="plotToggle" type="checkbox" /> <span>Show plot</span></label>
              <a id="previewLink" class="link" href="#" target="_blank">Preview CSV</a>
            </div>
          </div>
        </section>

        <section class="card hidden" id="chartCard">
          <canvas id="chart"></canvas>
        </section>

      </main>

      <footer>
        Served from ESP32 — <span id="buildInfo">UI v1</span>
      </footer>
    </div>

    <script>
      // --- API endpoints (firmware provides these) ---
      const API = {
        status: '/api/status',        // { temp, log, interval_ms }
        temp: '/api/temp',            // { t, ts }
        setInterval: '/api/set_interval', // POST ?ms=NNN
        startLog: '/api/start_log',   // POST
        preview: '/preview'
      };

      // UI elements
      const el = {
        tempValue: document.getElementById('tempValue'),
        tempMeta: document.getElementById('tempMeta'),
        statusText: document.getElementById('statusText'),
        intervalSelect: document.getElementById('intervalSelect'),
        setIntervalBtn: document.getElementById('setIntervalBtn'),
        startLogBtn: document.getElementById('startLogBtn'),
        previewLink: document.getElementById('previewLink'),
        plotToggle: document.getElementById('plotToggle'),
        chartCard: document.getElementById('chartCard'),
        chartCanvas: document.getElementById('chart'),
        themeToggle: document.getElementById('themeToggle')
      };

      // Lightweight state
      let statusTimer = null; let statusPollMs = 2000;
      let tempTimer = null; let tempPollMs = 1000;
      let samples = []; const maxSamples = 240;
      let plotOn = false; let visible = !document.hidden;

      // Theme handling
      function applyTheme(isLight){
        if(isLight) document.documentElement.style.colorScheme = 'light';
        else document.documentElement.style.colorScheme = 'dark';
      }
      el.themeToggle.addEventListener('change', e=> applyTheme(e.target.checked));

      // Fetch helpers
      async function fetchJson(path, opts){
        try{ const r = await fetch(path, opts); if(!r.ok) throw new Error('http '+r.status); const t = await r.json(); return t }catch(e){ console.warn('fetch error',path,e); return null }
      }

      async function sendSetInterval(seconds){
        const ms = Math.max(1, Math.round(seconds*1000));
        try{ const r = await fetch(API.setInterval + '?ms=' + ms, { method:'POST' }); return r.ok }catch(e){ return false }
      }

      async function sendStartLog(){
        try{ const r = await fetch(API.startLog, { method:'POST' }); return r.ok }catch(e){return false}
      }

      // Status polling
      async function pollStatus(){
        if(document.hidden) return; // pause when page hidden
        const data = await fetchJson(API.status);
        if(!data){ el.statusText.textContent = 'Offline'; return }
        el.statusText.textContent = 'OK';
        if(typeof data.temp !== 'undefined'){
          el.tempValue.textContent = Number(data.temp).toFixed(1);
        }
        const intervalSec = (data.interval_ms ? data.interval_ms/1000 : statusPollMs/1000);
        const logName = data.log || '-';
        el.tempMeta.textContent = 'log: ' + logName + ' • interval: ' + Number(intervalSec).toFixed(3) + 's';
        // adapt poll rates (status ~ interval, temp ~ 1s by default)
        const newStatusMs = Math.max(500, Math.min(60000, (data.interval_ms || statusPollMs)));
        if(Math.abs(newStatusMs - statusPollMs) > 20){ statusPollMs = newStatusMs; restartStatusPoll(); }
        if(plotOn && visible) drawPlot();
      }

      function startStatusPoll(){ if(statusTimer) clearInterval(statusTimer); statusTimer = setInterval(pollStatus, statusPollMs); }
      function restartStatusPoll(){ if(statusTimer) clearInterval(statusTimer); statusTimer = setInterval(pollStatus, statusPollMs); }
      function stopStatusPoll(){ if(statusTimer) clearInterval(statusTimer); statusTimer = null }

      async function pollTemp(){
        if(document.hidden || !plotOn) return;
        const d = await fetchJson(API.temp);
        if(d && typeof d.t !== 'undefined'){
          samples.push({t: d.ts || Date.now(), v: Number(d.t)});
          if(samples.length>maxSamples) samples.shift();
          if(visible) drawPlot();
        }
      }
      function startTempPoll(){ if(tempTimer) clearInterval(tempTimer); tempTimer = setInterval(pollTemp, tempPollMs); }
      function stopTempPoll(){ if(tempTimer) clearInterval(tempTimer); tempTimer = null }

      // Chart drawing (very small, no deps)
      function drawPlot(){
        const c = el.chartCanvas; const w = c.clientWidth; const h = c.clientHeight;
        const dpr = window.devicePixelRatio || 1; c.width = Math.max(1, Math.floor(w * dpr)); c.height = Math.max(1, Math.floor(h * dpr));
        const ctx = c.getContext('2d'); ctx.scale(dpr,dpr);
        // background
        ctx.clearRect(0,0,w,h);
        // prepare data
        if(samples.length<2) return;
        const values = samples.map(s=>s.v);
        const min = Math.min(...values); const max = Math.max(...values); const range = Math.max(0.1, max-min);
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(79,209,197,0.95)'; ctx.beginPath();
        for(let i=0;i<values.length;i++){
          const x = (i/(values.length-1))*(w-8)+4; const y = h - ((values[i]-min)/range)*(h-8)-4;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        // last value marker
        ctx.fillStyle = 'rgba(79,209,197,0.95)'; const last = values[values.length-1]; const lx = w-6; const ly = h - ((last-min)/range)*(h-8)-4;
        ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
      }

      // Visibility and plot toggle handling
      document.addEventListener('visibilitychange', ()=>{
        visible = !document.hidden;
        if(visible){ if(!statusTimer) startStatusPoll(); if(plotOn && !tempTimer) startTempPoll(); if(plotOn) drawPlot(); }
        else { stopStatusPoll(); stopTempPoll(); }
      });

      el.plotToggle.addEventListener('change', e=>{
        plotOn = e.target.checked;
        el.chartCard.classList.toggle('hidden', !plotOn);
        if(plotOn && visible){ startTempPoll(); drawPlot(); } else { stopTempPoll(); }
      });

      // Controls
      el.setIntervalBtn.addEventListener('click', async ()=>{
        const v = Number(el.intervalSelect.value);
        el.setIntervalBtn.disabled = true;
        const ok = await sendSetInterval(v);
        el.setIntervalBtn.disabled = false;
        if(ok) el.statusText.textContent = 'Interval set'; else el.statusText.textContent = 'Failed to set interval';
        setTimeout(()=>el.statusText.textContent = '',1200);
      });

      el.startLogBtn.addEventListener('click', async ()=>{
        el.startLogBtn.disabled = true;
        const ok = await sendStartLog();
        el.startLogBtn.disabled = false;
        el.statusText.textContent = ok? 'Logging started' : 'Failed to start';
        setTimeout(()=>el.statusText.textContent = '',1600);
      });

      el.previewLink.addEventListener('click', (ev)=>{
        ev.preventDefault(); window.open(API.preview, '_blank');
      });

      // Boot
      function init(){
        // set default interval select to common value
        el.intervalSelect.value = '5';
        // try initial poll immediately
        pollStatus(); startStatusPoll();
        // keep canvas size responsive
        window.addEventListener('resize', ()=>{ if(plotOn) drawPlot(); });
      }

      init();
    </script>
  </body>
</html>
