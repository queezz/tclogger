<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>ESP32 Temp Logger</title>
    <style>
      :root{
        --bg:#0f1720; --card:#0b1220; --text:#e6eef6; --muted:#9fb0c8; --accent:#4fd1c5;
        --ring: rgba(79,209,197,0.35);
      }
      @media (prefers-color-scheme: light){
        :root{ --bg:#f6f9fc; --card:#ffffff; --text:#06202b; --muted:#456275; --accent:#0ea5a4; --ring: rgba(14,165,164,0.25); }
      }
      html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial; background:var(--bg); color:var(--text); -webkit-font-smoothing:antialiased}
      .app{max-width:900px;margin:0 auto;padding:18px;box-sizing:border-box}
      header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
      h1{font-size:1rem;margin:0;color:var(--accent)}
      .controls{display:flex;gap:8px;flex-wrap:wrap}
      .card{background:var(--card);border-radius:14px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
      .main{display:grid;grid-template-columns:1fr;gap:12px}
      .temp-display{display:grid;grid-template-columns:1fr auto;align-items:center;gap:12px;padding:18px;border-radius:12px}
      .temp-left{display:flex;flex-direction:column;gap:6px;min-width:0}
      .temp-value{font-weight:800;font-size:3.8rem;line-height:1}
      .temp-meta{display:flex;flex-direction:column;gap:2px}
      .log-line{color:var(--muted);font-size:.95rem;word-break:break-all;overflow-wrap:anywhere}
      .interval-line{color:var(--muted);font-size:.95rem}
      .actions{display:grid;grid-template-columns:auto auto;gap:8px;align-items:center}
      .actions .row{display:flex;gap:8px;align-items:center}
      .actions .primary{grid-column:1 / -1}
      button, select{background:transparent;border:1px solid rgba(255,255,255,0.08);color:var(--text);padding:10px 12px;border-radius:10px;font-size:0.95rem}
      button:focus-visible, select:focus-visible{outline:none; box-shadow:0 0 0 3px var(--ring)}
      button.primary{background:linear-gradient(90deg,var(--accent),#7af0e6);color:#022029;border:0;font-weight:600}
      .muted{opacity:.85}
      #chart{width:100%;height:180px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);display:block}
      footer{margin-top:12px;color:var(--muted);font-size:.85rem;text-align:center}
      .toggle{display:inline-flex;align-items:center;gap:8px}
      .link{color:var(--accent);text-decoration:none}
      .hidden{display:none}
      select {
        background: var(--card);
        color: var(--text);
        border: 1px solid rgba(255,255,255,0.15);
      }

      select option {
        background: var(--card);
        color: var(--text);
      }

      button:hover:not(.primary),
      button:focus-visible:not(.primary) {
        background: rgba(255,255,255,0.06);
        border-color: var(--accent);
        cursor: pointer;
      }

      button.primary:hover,
      button.primary:focus-visible {
        filter: brightness(1.2);
        box-shadow: 0 0 6px var(--ring);
        cursor: pointer;
      }

      /* Mobile tweaks */
      @media (max-width:540px){
        .temp-display{grid-template-columns:1fr;align-items:start}
        .temp-value{font-size:3rem}
        .actions{grid-template-columns:1fr}
        .actions .row{width:100%}
        .actions select, .actions button{width:100%}
        .actions .primary{width:100%}
        .card{padding:12px}
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <h1>ESP32 Temp Logger</h1>
        <div class="controls">
          <label class="toggle" title="Toggle dark/light mode">
            <input id="themeToggle" type="checkbox" aria-label="Toggle theme" />
            <span class="muted">Dark / Light</span>
          </label>
        </div>
      </header>

      <main class="main">
        <section class="card temp-display" aria-live="polite">
          <div class="temp-left">
            <div class="temp-value" id="tempValue">--.-</div>
            <div class="temp-meta">
              <div id="logLine" class="log-line">log: —</div>
              <div id="intervalLine" class="interval-line">interval: —</div>
            </div>
          </div>
          <div class="actions">
            <div class="row">
              <select id="intervalSelect" aria-label="Sampling interval">
                <option value="1">1s</option>
                <option value="2">2s</option>
                <option value="5">5s</option>
                <option value="10">10s</option>
                <option value="30">30s</option>
                <option value="60">60s</option>
              </select>
              <button id="setIntervalBtn">Set</button>
            </div>
            <button id="startLogBtn" class="primary">Start Log</button>
          </div>
        </section>

        <section class="card" id="controlsCard">
          <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
            <div class="muted">Status: <span id="statusText">Connecting…</span></div>
            <div style="display:flex;gap:8px;align-items:center">
              <label class="toggle"><input id="plotToggle" type="checkbox" /> <span>Show plot</span></label>
              <a id="previewLink" class="link" href="#" target="_blank">Download CSV</a>
            </div>
          </div>
        </section>

        <section class="card hidden" id="chartCard">
          <canvas id="chart"></canvas>
        </section>

      </main>

      <footer>
        Served from aklab ESP32 — <span id="buildInfo">UI v1</span>
      </footer>
    </div>

    <script>
      // --- API endpoints (firmware provides these) ---
      const API = {
        status: '/api/status',
        temp: '/api/temp',
        setInterval: '/api/set_interval',
        startLog: '/api/start_log',
        preview: '/preview'
      };

      // UI elements
      const el = {
        tempValue: document.getElementById('tempValue'),
        logLine: document.getElementById('logLine'),
        intervalLine: document.getElementById('intervalLine'),
        statusText: document.getElementById('statusText'),
        intervalSelect: document.getElementById('intervalSelect'),
        setIntervalBtn: document.getElementById('setIntervalBtn'),
        startLogBtn: document.getElementById('startLogBtn'),
        previewLink: document.getElementById('previewLink'),
        plotToggle: document.getElementById('plotToggle'),
        chartCard: document.getElementById('chartCard'),
        chartCanvas: document.getElementById('chart'),
        themeToggle: document.getElementById('themeToggle')
      };

      // Lightweight state
      let statusTimer = null; let statusPollMs = 2000;
      let tempTimer = null; let tempPollMs = 1000;
      let lastTempTs = 0;
      let samples = []; const maxSamples = 240;
      let plotOn = false; let visible = !document.hidden;

      // Theme handling
      function applyTheme(isLight){
        if(isLight) document.documentElement.style.colorScheme = 'light';
        else document.documentElement.style.colorScheme = 'dark';
      }
      el.themeToggle.addEventListener('change', e=> applyTheme(e.target.checked));

      async function fetchJson(path, opts){
        try{ const r = await fetch(path, opts); if(!r.ok) throw new Error('http '+r.status); const t = await r.json(); return t }catch(e){ console.warn('fetch error',path,e); return null }
      }

      async function sendSetInterval(seconds){
        const ms = Math.max(1, Math.round(seconds*1000));
        try{ const r = await fetch(API.setInterval + '?ms=' + ms, { method:'POST' }); return r.ok }catch(e){ return false }
      }

      async function sendStartLog(newFile=false){
        const url = API.startLog + (newFile ? '?new=1' : '');
        try{ const r = await fetch(url, { method:'POST' }); return await r.json(); }catch(e){return null}
      }

      // Status polling
      async function pollStatus(){
        if(document.hidden) return;
        const data = await fetchJson(API.status);
        if(!data){ el.statusText.textContent = 'Offline'; return }
        el.statusText.textContent = 'OK';
        if(typeof data.temp !== 'undefined'){
          el.tempValue.textContent = Number(data.temp).toFixed(1);
        }
        const intervalSec = (data.interval_ms ? data.interval_ms/1000 : statusPollMs/1000);
        const logName = data.log || '-';
        el.logLine.textContent = 'log: ' + logName;
        el.intervalLine.textContent = 'interval: ' + Number(intervalSec).toFixed(3) + 's';

        const newStatusMs = Math.max(500, Math.min(60000, (data.interval_ms || statusPollMs)));
        if(Math.abs(newStatusMs - statusPollMs) > 20){ statusPollMs = newStatusMs; restartStatusPoll(); }
        if(plotOn && visible) drawPlot();
      }

      function startStatusPoll(){ if(statusTimer) clearInterval(statusTimer); statusTimer = setInterval(pollStatus, statusPollMs); }
      function restartStatusPoll(){ if(statusTimer) clearInterval(statusTimer); statusTimer = setInterval(pollStatus, statusPollMs); }
      function stopStatusPoll(){ if(statusTimer) clearInterval(statusTimer); statusTimer = null }

      async function pollTemp(){
        if(document.hidden || !plotOn) return;
        const d = await fetchJson(API.temp + (lastTempTs ? ('?after=' + encodeURIComponent(lastTempTs)) : ''));
        if(d && typeof d.t !== 'undefined'){
          const ts = d.ts || Date.now();
          lastTempTs = ts;
          samples.push({t: ts, v: Number(d.t)});
          if(samples.length>maxSamples) samples.shift();
          if(visible) drawPlot();
        }
      }
      function startTempPoll(){ if(tempTimer) clearInterval(tempTimer); tempTimer = setInterval(pollTemp, tempPollMs); }
      function stopTempPoll(){ if(tempTimer) clearInterval(tempTimer); tempTimer = null }

      function fmtDur(ms){ if(ms>=60000){ const m=Math.round(ms/60000); return m+"m" } const s=Math.round(ms/1000); return s+"s" }

      // Chart drawing (very small, no deps)
      function drawPlot(){
        const c = el.chartCanvas; const w = c.clientWidth; const h = c.clientHeight;
        const dpr = window.devicePixelRatio || 1; c.width = Math.max(1, Math.floor(w * dpr)); c.height = Math.max(1, Math.floor(h * dpr));
        const ctx = c.getContext('2d'); ctx.scale(dpr,dpr);
        ctx.clearRect(0,0,w,h);
        if(samples.length<2) return;
        const values = samples.map(s=>s.v);

        // layout margins
        const mL = 36, mR = 8, mT = 8, mB = 22;
        const plotW = Math.max(1, w - mL - mR);
        const plotH = Math.max(1, h - mT - mB);

        // data extents with small padding
        let vMin = Math.min(...values), vMax = Math.max(...values);
        let vRange = vMax - vMin; if(vRange < 0.1){ vRange = 0.1; vMin = vMin - 0.05; vMax = vMin + 0.1; }
        const pad = vRange*0.08; const yMin = vMin - pad; const yMax = vMax + pad; const ySpan = yMax - yMin;

        // grid + axes
        ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
        const yTicks = [yMin, (yMin+yMax)/2, yMax];
        yTicks.forEach(tv=>{
          const y = mT + plotH - ((tv - yMin)/ySpan)*plotH;
          ctx.beginPath(); ctx.moveTo(mL, y); ctx.lineTo(mL+plotW, y); ctx.stroke();
        });
        ctx.beginPath(); ctx.moveTo(mL, mT); ctx.lineTo(mL, mT+plotH); ctx.lineTo(mL+plotW, mT+plotH); ctx.stroke();

        // labels
        ctx.fillStyle = 'rgba(159,176,200,0.95)'; ctx.font = '12px system-ui'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
        yTicks.forEach(tv=>{
          const y = mT + plotH - ((tv - yMin)/ySpan)*plotH;
          ctx.fillText(tv.toFixed(1), mL - 6, y);
        });
        const t0 = samples[0].t || Date.now(); const tN = samples[samples.length-1].t || Date.now();
        const spanMs = Math.max(1, tN - t0);
        ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText('-'+fmtDur(spanMs), mL, mT+plotH+4);
        ctx.fillText('-'+fmtDur(spanMs/2), mL + plotW/2, mT+plotH+4);
        ctx.textAlign = 'right'; ctx.fillText('now', mL+plotW, mT+plotH+4);

        // series
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(79,209,197,0.95)'; ctx.beginPath();
        for(let i=0;i<values.length;i++){
          const x = mL + (i/(values.length-1))*plotW; const y = mT + plotH - ((values[i]-yMin)/ySpan)*plotH;
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.fillStyle = 'rgba(79,209,197,0.95)'; const last = values[values.length-1]; const lx = mL+plotW; const ly = mT + plotH - ((last-yMin)/ySpan)*plotH;
        ctx.beginPath(); ctx.arc(lx,ly,4,0,Math.PI*2); ctx.fill();
      }

      document.addEventListener('visibilitychange', ()=>{
        visible = !document.hidden;
        if(visible){ if(!statusTimer) startStatusPoll(); if(plotOn && !tempTimer) startTempPoll(); if(plotOn) drawPlot(); }
        else { stopStatusPoll(); stopTempPoll(); }
      });

      el.plotToggle.addEventListener('change', e=>{
        plotOn = e.target.checked;
        el.chartCard.classList.toggle('hidden', !plotOn);
        if(plotOn && visible){ samples = []; startTempPoll(); drawPlot(); } else { stopTempPoll(); }
      });

      el.setIntervalBtn.addEventListener('click', async ()=>{
        const v = Number(el.intervalSelect.value);
        el.setIntervalBtn.disabled = true;
        const ok = await sendSetInterval(v);
        el.setIntervalBtn.disabled = false;
        if(ok) el.statusText.textContent = 'Interval set'; else el.statusText.textContent = 'Failed to set interval';
        setTimeout(()=>el.statusText.textContent = '',1200);
      });

      el.startLogBtn.addEventListener('click', async ()=>{
        if (!confirm('Start logging?')) return;
        el.startLogBtn.disabled = true;
        const res = await sendStartLog(false);
        if (!res || res.ok === false){ el.statusText.textContent = 'Failed to start'; el.startLogBtn.disabled = false; setTimeout(()=>el.statusText.textContent = '',1600); return; }
        if (res.running && res.log){
          const yes = confirm(`Already logging:\n${res.log}\n\nStart a NEW file?`);
          if (yes){ const r2 = await sendStartLog(true); el.statusText.textContent = (r2 && r2.ok) ? 'New file started' : 'Rotate failed'; }
          else { el.statusText.textContent = 'Kept current file'; }
        } else {
          el.statusText.textContent = 'Logging started';
        }
        el.startLogBtn.disabled = false;
        setTimeout(()=>el.statusText.textContent = '',1600);
      });

      el.previewLink.addEventListener('click', (ev)=>{
        ev.preventDefault(); window.open(API.preview, '_blank');
      });

      function init(){
        el.intervalSelect.value = '5';
        pollStatus(); startStatusPoll();
        window.addEventListener('resize', ()=>{ if(plotOn) drawPlot(); });
      }
      init();
    </script>
  </body>
</html>
